# Commands

## Minikube

```bash
$ minikube start driver=hyperv --v=7 --alsologtostderr
start cluster in debug mode.

$ minikube start -n 3 --driver=hyperv --container-runtime=containerd -cni=calico

$ minikube node list
list all nodes of clusters.

$ minikube node list -p minibox
list nodes of minibox cluster (-p option used to profile a cluster).

$ minikube ip
to display cluster control plane nodes IP

$ minikube profile list
view the status of all your cluster in table format  
(*) active  marker indicates the target cluster profile  
 of minikube command line tool.

$ minikube profile _____
you can set to other cluster.

$ minikube config set driver hyperv
to set default driver.

$ minikube start --driver=none
to runs kubernetes component on bare-metal (req docker).

$ minikube ip
get the IP address of the minikube VM

$ minikube service [service name] [--url]
```

## Kubectl commands

```bash
$ kubectl get nodes

$ kubectl get pods

$ kubectl get services 
one default service.

$ kubectl create  deployment NAME --image=image [--dry-run] [options]

$ kubectl create deployment nginx-depl --image=nginx
create deployment whicch automatically create pods and manage replica.

$ kubectl get deployment

$ kubectl edit deployment nginx-depl
Autogenerated config file you can 

$ kubectl get replicaset

$ kubectl logs [pod name]
to debug pods.

$ kubectl get all
to get all service running on cluster

$ kubectl create deployment mongo-depl --image=mongo

$ kubectl exec -it [pod name] -- bin/bash
it will get the terminal of running container

$ kubectl delete deployment [deploy name]

$ kubectl apply -f [file name]
take input as file and executes it.

$ kubectl get secret

$ kubectl create -f [file name]
creates the deployment from the YAML config file.

$ kubectl run firstrun --image=nginx --port88 \
 --dry-run=client -o yaml > secondrun.yaml
get config file of first run in secondrun.yaml, change accordingle

$ kubectl replace --force -f secondrun.yaml
forcefully change secondrun yaml file
```

```bash
$ kubectl describe service [service name]
to validate the service has right pod to  
forward the request to (check endpoints,
 selectors, target points)

$ kubectl get pods -o wide
to get more info about pods.

$ kubectl get deployment nginx-deployment
 -o yaml > nginx-deployment-result.yaml
to see status part of config file.

$ kubectl delete -f [file name]

$ kubectl expose deployment [deploy name] 
  --name=web-service --type=NodePort 
expose deployment 
```

## Example 1

```bash
$ minikube start

$ kubectl create deployment hello-node 
  --image=registry.k8s.io/e2e-test-images/agnhost:2.39
  -- /agnhost netexec --http-port=8080

$ kubectl get deployments

$ kubectl get pods

$ kubectl get events

$ kubectl config view

$ kubectl logs [container name]
By default, the pod is accessible by its internal IP address within the kubernetes cluster. To make hello-node container accessible from outside the kubernetes virtual network, expose the pod as kubernetes service.

$ kubectl expose deployment hello-node 
  --type=LoadBalancer --port=8080

$ kubectl get service

$ minikube service hello-node
opens up browser window that serves your app

$ minikube addons enable metrics-server

$ kubectl get pod, svc -n kube-system

$ kubeclt top pods

$ kubectl delete service hello-node
$ kubectl delete deployment hello-node
```

## Example 2

```yaml

# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-leader
  labels:
    app: redis
    role: leader
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
        role: leader
        tier: backend
    spec:
      containers:
      - name: leader
        image: "docker.io/redis:6.0.5"
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379

```

```bash
kubectl apply -f redis-leader-deployment.yaml
```

```yaml

# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: v1
kind: Service
metadata:
  name: redis-leader
  labels:
    app: redis
    role: leader
    tier: backend
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis
    role: leader
    tier: backend

```

The guestbook application needs to communicate to the Redis to write its data. You need to apply a service to proxy the traffic to the Redis Pod.

```bash
kubectl apply -f redis-leader-service.yaml
```

```yaml
# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-follower
  labels:
    app: redis
    role: follower
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
        role: follower
        tier: backend
    spec:
      containers:
      - name: follower
        image: us-docker.pkg.dev/google-samples/containers/gke/gb-redis-follower:v2
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 6379

```

Redis leader is a single Pod, you can make it highly available and meet traffic demands by adding a few redis follower.

```bash
kubectl apply -f redis-follower-deployment.yaml
```

```yml
# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: v1
kind: Service
metadata:
  name: redis-follower
  labels:
    app: redis
    role: follower
    tier: backend
spec:
  ports:
    # the port that this service should serve on
  - port: 6379
  selector:
    app: redis
    role: follower
    tier: backend

```

The guestbook application needs to communicate with the redis followers to read data. to make the redis followers discoverable you must set up another service.

```bash
kubectl apply -f redis-follower-service.yaml
```

Now that you have the Redis storage of your guestbook up and running, start the guestbook web servers. Like the Redis followers, the frontend is deployed using a Kubernetes Deployment.

The guestbook app uses a PHP frontend. It is configured to communicate with either the Redis follower or leader Services, depending on whether the request is a read or a write. The frontend exposes a JSON interface, and serves a jQuery-Ajax-based UX.

```yaml

# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
        app: guestbook
        tier: frontend
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: us-docker.pkg.dev/google-samples/containers/gke/gb-frontend:v5
        env:
        - name: GET_HOSTS_FROM
          value: "dns"
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 80

```

```bash
kubectl apply -f frontend-deployment.yaml
```

If you want guest to be able to access your guestbook, you must configure the frontend service to be externally visible, so a client can request the service to be externally visible.

```yml

# SOURCE: https://cloud.google.com/kubernetes-engine/docs/tutorials/guestbook
apiVersion: v1
kind: Service
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # if your cluster supports it, uncomment the following to automatically create
  # an external load-balanced IP for the frontend service.
  # type: LoadBalancer
  #type: LoadBalancer
  ports:
    # the port that this service should serve on
  - port: 80
  selector:
    app: guestbook
    tier: frontend

```

```bash
$ kubectl apply -f frontend-service.yaml
```

View the frontend service via kubectl port-forward

```bash
kubectl port-forward svc/frontend 8080:80
```

View the Frontend Service via load balancer

If you deployed the frontend-service.yaml manifest with type: LoadBalancer you need to find the IP address to view your Guestbook.

```bash
$ kubectl get service frontend
copy the external ip address and load the page in local browser.

$ kubectl scale deployment frontend --replicas=5
Scale the web frontend
```

